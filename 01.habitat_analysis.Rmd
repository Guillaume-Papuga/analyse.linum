---
title: "01.habitat_analysis"
author: "Guillaume Papuga"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

```{r packages}
require(ade4)
require(here)
library(tidyverse)
library(stringr)
library(reshape2)
library(ggpubr)
library(statisticalModeling)
library(corrplot)
```

```{r data loading}
# raw table
d.hab = read.csv(here::here("data","processed", "d.hab.txt"), sep = ";", dec = ".")
d.soil = read.csv(here::here("data","processed", "d.soil.txt"), sep = ";", dec = ".")

# merged table
d.niche = inner_join(d.hab, d.soil, # inner_join elimine =-15 pops
                     by = c("code.pop", "species", "status"))
d.niche = d.niche %>%
  mutate (shrub = small_shrbs + tall_shrbs)
```

# Introduction
Here I explain the structure of the section.

# 1. Trait by trait analysis
```{r format plot without display}
# This first chunk aims at producing all the different plots
# through a for loop, without displaying anything
# Specific chuncks are used to format the document

# Defining tables & varaibles
var = colnames (d.niche) [c(7:14, 16, 18:31)]
d.niche.l = melt(d.niche [, c("code.pop", "species", "status", var)], 
                 id.vars = c("code.pop", "species", "status"))

# Main loop to draw all the graphs
for (i in var) {
  # prepare the table
  tab = d.niche.l %>%
    filter(variable == i)
  
  # mean
  m_sp = tab %>%
    group_by(species) %>%
    summarise(grp.mean = mean(value, na.rm = T))
  
  ## Graphique n°1 : historgramme global des valeurs
  # plot
  assign(paste0("hist.plot_", i),
  ggplot(data = tab, aes(x= value, color=species, fill=species)) +
    geom_histogram(aes(y=..density..), position="identity", alpha=0.5)+
    geom_density(alpha=0.6) +
    geom_vline(data = m_sp, aes(xintercept = grp.mean, color=species), linetype="dashed") +
    scale_color_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
    scale_fill_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
    labs(title="Trait per species histogram plot", x = (i), y = "Density")+
    theme_classic())

  ## Graphique n°2 : barplot des moyennes par espèce
  # plot
  assign(paste0("vio.plot_", i),
  ggplot(data = tab, aes(x =  species, y = value, fill = species)) +
    geom_violin() +
    labs(title="Trait per species plot", y = i)+
    scale_color_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
    scale_fill_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
    geom_boxplot(width=0.05) +
    stat_compare_means(method = "t.test") + # add p.value from a simple t.test
    theme_classic())
  
  ## Graphique 3 : barplot des moyennes par espèce par status (mixed VS pure)
  # plot
  assign(paste0("box.plot_", i),
  ggplot(data = tab, aes(x =  species, y = value, fill = status)) +
    geom_boxplot() +
    labs(title="Trait per species*status plot", y = i)+
    scale_color_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
    scale_fill_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
    stat_compare_means(aes(label = paste0("p = ", ..p.format..))) + # add p.value from a simple t.test
    theme_classic())
}
```

The dataset is composed of `length(var)` variables : 
`print (var)`

## "annual_herbs" 
```{r}
hist.plot_annual_herbs
vio.plot_annual_herbs
```
There is no difference in the coverage of annual herbs, which is always very low (<1%)

```{r}
box.plot_annual_herbs
```
No differences.

## "perennial_herbs" 
```{r}
hist.plot_perennial_herbs
vio.plot_perennial_herbs
```
Perennial herbs show important cover ~50%, but with a large dispersion.

```{r}
box.plot_perennial_herbs
```
No difference. 

## "tot_herbs"
```{r}
hist.plot_tot_herbs
vio.plot_tot_herbs
```

Very similar to the perennial herbs plot.

```{r}
box.plot_tot_herbs
```

## "small_shrbs"  
```{r}
hist.plot_small_shrbs
vio.plot_small_shrbs
```
Very close values just below 20%. 

```{r}
box.plot_small_shrbs
```
No difference.

## "tall_shrbs"    
```{r}
hist.plot_tall_shrbs
vio.plot_tall_shrbs
```
Tall shrubs show similar cover. 
```{r}
box.plot_tall_shrbs
```

## "shrub"  
```{r}
hist.plot_shrub
vio.plot_shrub
```

```{r}
box.plot_shrub
```

## "trees"       
```{r}
hist.plot_trees
vio.plot_trees
```
The habitat isn't covered by trees that reach a ~20% cover (typical garrigue)
```{r}
box.plot_trees
```

## "bare_soil"   
```{r}
hist.plot_bare_soil
vio.plot_bare_soil
```
No difference regarding the extent of bare soil. 

```{r}
box.plot_bare_soil
```

## "mineral"  
```{r}
hist.plot_mineral
vio.plot_mineral
```
No difference regarding the amount of mineral. It could have been expected that L. suffruticosum occur where mineral shows more important vale, but it is insignificant compared to the global dataset.
```{r}
box.plot_mineral
```

## "nb_ind_class" 
This is not a variable, it's a control for pop size.
```{r}
hist.plot_nb_ind_class
vio.plot_nb_ind_class
```
The usual population size was equivalent but some L. suffruticosum were extremely large, which we never found for the other species. 

```{r}
box.plot_nb_ind_class
```

## "area_med" 
Same as above
```{r}
hist.plot_area_med
vio.plot_area_med
```
Similarly, most population covered <5000m2. 

```{r}
box.plot_area_med
```

## "ca"    
```{r}
hist.plot_ca
vio.plot_ca
```
The amount of CA (calcareous particles) is very much the same for both species.

```{r}
box.plot_ca
```

## "mg"  
```{r}
hist.plot_mg
vio.plot_mg
```
No differences between taxa, skewed toward lower values. 

```{r}
box.plot_mg
```

## "k"   
```{r}
hist.plot_k
vio.plot_k
```
No differences btw taxa. 

```{r}
box.plot_k
```

## "cond"  
```{r}
hist.plot_cond
vio.plot_cond
```
Conductivity is very similar. 

```{r}
box.plot_cond
```

## "p"   
```{r}
hist.plot_p
vio.plot_p
```
Nearly similar. 

```{r}
box.plot_p
```

## "mo"   
```{r}
hist.plot_mo
vio.plot_mo
```
Similar content of organic matter.

```{r}
box.plot_mo
```

## "n"   
```{r}
hist.plot_n
vio.plot_n
```
Similar levels of nitrogen (n)
```{r}
box.plot_n
```

## "ph"  
```{r}
hist.plot_ph
vio.plot_ph
```
Very similar basic pH with some exception in L. suffruticosum (outliers).

```{r}
box.plot_ph
```

## "cn"    
```{r}
hist.plot_cn
vio.plot_cn
```
Low Carbon/nitrogen ratio of ~11. 

```{r}
box.plot_cn
```

## "arcilla" 
```{r}
hist.plot_arcilla
vio.plot_arcilla
```
No difference in arcilla
```{r}
box.plot_arcilla
```

## "arena"  
```{r}
hist.plot_arena
vio.plot_arena
```

```{r}
box.plot_arena
```

## "limo"  
```{r}
hist.plot_limo
```

```{r}
vio.plot_limo
```

```{r}
box.plot_limo
```

## Conclusion
There is no difference in soil nor habitat characteristics among the two taxa. Their niche is so highly similar it sometime makes me doubt about how random this can be...

 
# 2. Multivariate approach
## Correlation structure among variables
### a. PCA
We decompose the analysis between soil & habitat variables. 

```{r}
# Define the variables
var.hab = var[c(1:8, 23)]
var.soil = var[11:22]

# Run a PCA for habitat
mat.pca.hab = d.niche %>%
  select(species, var.hab)
mat.pca.hab[is.na(mat.pca.hab)] = 0
pca.hab = dudi.pca (mat.pca.hab[,-1], 
                    scannf = F, nf = 2)
s.corcircle(pca.hab$co)

# Save the plot
pdf(file = here::here("outputs", "figures", "corcircle.hab.pdf")) # open
s.corcircle(pca.hab$co) # the plot
dev.off() # close
```
This first correlation plot gives insights on the correlation structure of the dataset : 
- perennial herb and total herbs are correlated >> total herbs
- mineral is anticorrelated with the two first >> delete
- small shrubs, tall shrubs and shrub >> keep shrub
- conserve bare soil over mineral
- maybe keep also tree (low correlation, but ecologicaly significant)

```{r}
# Run a PCA for soil
mat.pca.soil = d.niche %>%
  select(species, var.soil)
mat.pca.soil[is.na(mat.pca.soil)] = 0
pca.soil = dudi.pca (mat.pca.soil[,-1], 
                    scannf = F, nf = 2)
s.corcircle(pca.soil$co)

# Save the plot
pdf(file = here::here("outputs", "figures", "corcircle.soil.pdf")) # open
s.corcircle(pca.soil$co) # the plot
dev.off() # close
```
Regarding soil variables
- Organic Matter represents p, n, and cond >> keep OM
- Arena/arcilla are anti-correlated >> keep arena (ecologicaly relevant)
- pH must be correlated to mo ! delete
- keep cn
- check for mg, ca, k



### b. Corplot
```{r}
# build a function to calculate the significance of correlations
# mat : matrice de donnée
# ... : Arguments supplémentaire à passer à la fonction cor.test
cor.mtest <- function(mat, ...) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
        for (j in (i + 1):n) {
            tmp <- cor.test(mat[, i], mat[, j], ...)
            p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
        }
    }
  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  p.mat
}
```

```{r corplot hab}
# matrix
mat.pca.hab = d.niche %>%
  select(species, var.hab)
mat.pca.hab[is.na(mat.pca.hab)] = 0

# Build a matrix of p-value correlation
p.mat = cor.mtest(mat.pca.hab[,-1])

# Draw a corplot for habitat variables
col = colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))
M=cor(mat.pca.hab[,-1]) # build a correlation matrix
corrplot(M, method="color", col=col(200),  
         type="upper", order="hclust", 
         addCoef.col = "black", # Ajout du coefficient de corrélation
         tl.col="black", tl.srt=45, #Rotation des etiquettes de textes
         # Combiner avec le niveau de significativité
         p.mat = p.mat, sig.level = 0.01, insig = "blank", 
         # Cacher les coefficients de corrélation sur la diagonale
         diag=FALSE)
```

This brings some additionnal infos : 
- keep shrub, tree, tot herbs
- check for mineral and bare soil


```{r corplot soil}
# matrix
mat.pca.soil = d.niche %>%
  select(species, var.soil)
mat.pca.soil[is.na(mat.pca.soil)] = 0

# Build a matrix of p-value correlation
p.mat = cor.mtest(mat.pca.soil[,-1])

# Draw a corplot for habitat variables
col = colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))
M=cor(mat.pca.soil[,-1]) # build a correlation matrix
corrplot(M, method="color", col=col(200),  
         type="upper", order="hclust", 
         addCoef.col = "black", # Ajout du coefficient de corrélation
         tl.col="black", tl.srt=45, #Rotation des etiquettes de textes
         # Combiner avec le niveau de significativité
         p.mat = p.mat, sig.level = 0.01, insig = "blank", 
         # Cacher les coefficients de corrélation sur la diagonale
         diag=FALSE)
```
Regarding soil variables
- Organic Matter represents p, n, and cond >> keep OM
- Arena/arcilla are anti-correlated >> keep arena (ecologicaly relevant)
- pH must be correlated to mo ! delete
- keep cn
- check for mg, ca, k

### c. Variance Inflation Factor (VIF)
```{r}
# habitat
# var.hab : annual_herbs, perennial_herbs, tot_herbs, small_shrbs, tall_shrbs, trees, bare_soil, mineral  
collinearity( ~ tot_herbs+small_shrbs+trees+bare_soil, data = mat.pca.hab)
```

```{r}
# soil
# var.hab : ca, mg, k, cond, p, mo, n, ph, cn, arcilla, arena, limo

collinearity( ~ ca+mg+k+cond+p+mo+n+ph+cn+arena, data = mat.pca.soil)
```


### d. Conclusion and variable selection
For habitat, we conserve X variables : 
- total herbs
-

For soil, we conserva X variables : 
- arena
-

This leads to X variables overal.

## Principal Component Analysis
```{r}
var = var.soil # adapte le code à la var
data.linum = data.linum.soil # adapte le code a la var

# 2a. Pairs table to investigate multi-collinearity
# first, créer la fonction panel.cor dans l'aide de pairs
mat.pairs = na.omit(data.linum[,c("species", var)]) # avec var.bhab pour le deuxième
pairs(mat.pairs, lower.panel = panel.smooth, upper.panel = panel.cor,pch=16,cex=1)

# 2b. PCA 
matrice.pca = data.linum[,c("species",var)]  # choisi var.soil ou var.bhab
matrice.pca = na.omit(matrice.pca)
pca.linum = dudi.pca(matrice.pca[,var], scannf = FALSE, nf = 2)

# définit la zone d'impression
pdf(file = paste("PCA_bhab.pdf",sep=""),width=8, height=10) # lancer l'impression automatique en pdf
zones = matrix(c(1,2,3),ncol=1,nrow=3,byrow=TRUE) # définir la fenetre graphique
layout(zones,widths=c(1),heights=c(1,1,1)) # définir la hauteur et la largeur des cases
par(mar = c(4,4,1,4)) # marges

# les trois graphs
s.corcircle(pca.linum$co,clabel=0.9,grid=F,box=F)
s.label(pca.linum$li,clabel=0.9,grid=F,box=F)
w.ax1=round((pca.linum$eig[1]/sum(pca.linum$eig))*100,1)
text(3,1.5,paste("Axe 1 : ",w.ax1),adj=0)
w.ax2=round((pca.linum$eig[2]/sum(pca.linum$eig))*100,1)
text(3,2,paste("Axe 2 : ",w.ax2),adj=0)
s.class(pca.linum$li,fac=as.factor(matrice.pca$species),clabel=0.9,grid=F)

par(mfrow=c(1,1)) # ferme la fenetre
dev.off() #arrête PDF 


# 2c. with only "non correlated variables" variables > UNIQUEMENT POUR SOIL! Pas de correlation chez Bhab
var.red = c("mg", "k", "cond", "mo" , "ph", "cn", "arcilla",  "limo") # selectionne pour soil
# enlevé : "n", "p" (MO), "ca" (K), "arena" (Arcilla)
matrice.pca = data.linum[,c("species", var.red)]
matrice.pca = na.omit(matrice.pca)
pca.linum = dudi.pca(matrice.pca[,var.red], scannf = FALSE, nf = 2)

# définit la zone d'impression
pdf(file = paste("PCA_soil.red.comp",".pdf",sep=""),width=8, height=10) # lancer l'impression automatique en pdf
zones=matrix(c(1,2,3),ncol=1,nrow=3,byrow=TRUE) # définir la fenetre graphique
layout(zones,widths=c(1),heights=c(1,1,1)) # définir la hauteur et la largeur des cases
par(mar = c(4,4,1,4)) # marges

# les trois graphs
s.corcircle(pca.linum$co,clabel=0.9,grid=F,box=F)
s.label(pca.linum$li,clabel=0.9,grid=F,box=F)
w.ax1=round((pca.linum$eig[1]/sum(pca.linum$eig))*100,1)
text(5,1.5,paste("Axe 1 : ",w.ax1))
w.ax2=round((pca.linum$eig[2]/sum(pca.linum$eig))*100,1)
text(5,2,paste("Axe 2 : ",w.ax2))
s.class(pca.linum$li,fac=as.factor(matrice.pca$species),clabel=0.9,grid=F)

par(mfrow=c(1,1)) # ferme la fenetre
dev.off() #arrête PDF
```

```{r}
###
# 3. Test differences : is there a difference between groups?
###
library (vegan)
var = var.bhab # adapte le code à la var
data.linum = data.linum.bhab # adapte le code a la var

# 3a. NP MANOVA [permutational non parametric ANOVA] : Adonis2 (more robust in most case)
adonis2(data.linum[,var] ~ species, data = data.linum, 
        permutations = 999, method = "Bray")

adonis2(data.linum[,var] ~ species, data = data.linum, 
        permutations = 999, method = "euclidean")

adonis2(data.linum[,var] ~ species, data = data.linum, 
        permutations = 999, method = "mahalanobis")


# 3b. MRPP [multi response permutation procedure]
linum.mrpp = with(data.linum, mrpp(data.linum[,var], species)) # euclidean dissimilarity index
linum.mrpp
```



## Analyse discriminante 

```{r}
### A. Linéaire (LDA)

# packages
library(adegraphics)
library(MASS)

# data
data.linum = data.linum.bhab
var = var.bhab

# crée la matrice
matrice.lda = data.linum[,var]
factor.da = data.linum[,"species"]
matrice.lda = na.omit(matrice.lda)

# testing the normality of variance-covariance matrix
library (MVN)
suf = data.linum[which(data.linum$species == "Linum suffruticosum"), var] # suffruticosum
ten = data.linum[which(data.linum$species == "Linum tenuifolium"), var] # tenuifolium

res.mardia.suf = mvn(data = suf, mvnTest = "mardia")
result$multivariateNormality

result = mvn(data = data.linum[,c("species",var)], subset = "species", mvnTest = "mardia",
             univariateTest = "AD", univariatePlot = "histogram",
             multivariatePlot = "qq", multivariateOutlierMethod = "adj",
             showOutliers = TRUE, showNewData = TRUE)
result$multivariateNormality

# testing the homogeneity of variance-covariance matrix
library (heplots)
res <- boxM(matrice.lda, factor.da)

dets <- res$logDet
ng <- length(res$logDet)-1
points(dets , 1:3,  
       cex=c(rep(1.5, ng), 2.5), 
       pch=c(rep(16, ng), 15),
       col= c(rep("blue", ng), "red"))

# selectionne les variables sur la base de la PCA d'avant
linum.lda = lda(factor.da~., data = matrice.lda, prior = c(1, 1)/2, CV = TRUE)

# Assess the accuracy of the prediction
# percent correct for each category of G
ct <- table(factor.da, linum.lda$class) # contingency table

diag(prop.table(ct, 1)) # proportion on the contingency table (diag prend juste la diag = les justes)
sum(diag(prop.table(ct))) # total des prédictions justes


### B. Quadratic (discriminant function does not assume homogeneity of variance-covariance matrices)

linum.qda = qda(factor.da~., data = matrice.lda, prior = c(1, 1)/2, CV = TRUE)
plot (linum.qda)

# Assess the accuracy of the prediction
# percent correct for each category of G
ct <- table(factor.da, linum.qda$class) # contingency table

diag(prop.table(ct, 1)) # proportion on the contingency table (diag prend juste la diag = les justes)
sum(diag(prop.table(ct))) # total des prédictions justes

### C. graphs
plot (linum.lda)
plot (linum.lda, dimen=1, type="both") 

# Exploratory Graph for LDA or QDA
library(klaR)
part.plot = partimat(factor.da~., data = matrice.lda, method="lda") 

# graph pairs
pairs(matrice.lda, main = "Pair plots", pch=22,
      bg=c("red", "blue")[unclass(factor.da)]) 

###
# 5. PLS DA
###



###
# 6. Structure spatiale
###
################################## Vieux code à reprendre ###########################@
# 2d. Structure spatiale des données
mat.spa.str=merge(data.linum,pca.linum$li,by="row.names",all=T)
data(wrld_simpl) # plot carte globale
plot(wrld_simpl, xlim=c(0,10), ylim=c(42,47), axes=TRUE, col='light yellow') # cadre sur Med ouest
data.linum.suf=na.omit(mat.spa.str[which(mat.spa.str$species=="Linum suffruticosum"),c("longitude","latitude","Axis1","Axis2")]) # selectionne données L. suf pour en tirer les coordonnées GPS (avec les valeurs axis 1 et 2 pour la taille des points)
data.linum.ten=na.omit(mat.spa.str[which(mat.spa.str$species=="Linum tenuifolium"),c("longitude","latitude","Axis1","Axis2")]) # idem
points(data.linum.suf$longitude,data.linum.suf$latitude,pch=16,cex=(data.linum.suf$Axis1 - (min(data.linum.suf)) +1)/6,col="red")  # la taille des points est basée sur 'val Axis1' + minimum Axis 1 + 1, pour etre sur d'avoir des valeur positives dans le CEX
points(data.linum.ten$longitude,data.linum.ten$latitude,pch=16,cex=(data.linum.ten$Axis1 - (min(data.linum.ten)) +1)/6,col="blue")

points(data.linum.suf$longitude,data.linum.suf$latitude,pch=16,cex=((data.linum.suf$Axis1)+5)/5,col="red")
points(data.linum.ten$longitude,data.linum.ten$latitude,pch=16,cex=((data.linum.ten$Axis1)+5)/5,col="blue")

# autocorrelation spatiale
head(data.linum[,var.soil])
dist.dudi(na.omit(data.linum[,var.soil]))
dist.dudi(pca.linum)




# 3c. Mantel test
lsuf.dist <- vegdist(data.linum[which(data.linum$species == "Linum suffruticosum"), var]) # Bray-Curtis
lten.dist <- vegdist(data.linum[which(data.linum$species == "Linum tenuifolium"), var]) # Bray-Curtis
mantel(lsuf.dist, lten.dist)
mantel(veg.dist, env.dist, method="spear")


```



